###
# Parameters Used By Script
###
Param (
	[Parameter(Mandatory=$TRUE, ValueFromPipeline=$TRUE, ValueFromPipelineByPropertyName=$TRUE,
		HelpMessage='Please specify the FQDN of the Entra ID Tenant to target')]
    [ValidateNotNullOrEmpty()]
	[string]$tenantFQDN,
	[Parameter(Mandatory=$TRUE, ValueFromPipeline=$TRUE, ValueFromPipelineByPropertyName=$TRUE,
		HelpMessage='Please specify the name of the Application Registration')]
    [ValidateNotNullOrEmpty()]
	[string]$appRegDisplayName,
	[string]$customLifetimeSecretInDays,
	[switch]$createOrUpdateApp,
	[switch]$deleteApp,
	[switch]$updateAPIPerms,
	[switch]$createClientSecret,
	[switch]$deleteAllClientSecrets,
	[switch]$listAllClientSecrets
)

###
# Version Of Script
###
$version = "v0.8, 2024-12-09"

<#
	AUTHOR
		Written By....................: Jorge de Almeida Pinto
		Re-Written By.................: N.A.
		Company.......................: SEMPERIS [https://www.semperis.com/]

	DISCLAIMER
		- The script is FREEWARE, you are free to distribute/update it, but always refer to this website (https://github.com/Semperis/) as the location where you got it
		- This script is furnished "AS IS". NO warranty is expressed or implied!
		- I/We HAVE NOT tested it in every scenario or environment
		- ALWAYS TEST FIRST in lab environment to see if it meets your needs!
		- Use this script at YOUR OWN RISK! YOU ARE RESPONSIBLE FOR ANY OUTCOME/RESULT BY USING THIS SCRIPT!
		- I/We DO NOT warrant this script to be fit for any purpose, use or environment!
		- I/We have tried to check everything that needed to be checked, but I/We DO NOT guarantee the script does not have bugs!
		- I/We DO NOT guarantee the script will not damage or destroy your system(s), environment or anything else due to improper use or bugs!
		- I/We DO NOT accept liability in any way when making mistakes, use the script wrong or in any other way where damage is caused to your environment/systems!
		- If you do not accept these terms DO NOT use the script in any way and delete it immediately!

	TODO
		- N.A.

	KNOWN ISSUES/BUGS
		- Only works with PowerShell 7.4 and higher (because of using the "PSMSALNet PowerShell Module")

	RELEASE NOTES
		v0.8, 2024-12-09, Jorge de Almeida Pinto [MVP-EMS]:
			- Removed dependency on/use of MSGRAPH PowerShell Module
			- Removed dependency on/use of AZ.ACCOUNTS PowerShell Module
			- Added dependency on/use of PSMSALNet PowerShell Module (https://github.com/SCOMnewbie/PSMSALNet)
				- Script checks for its availability
			- Only works with PowerShell 7.4 and higher (because of using the "PSMSALNet PowerShell Module")
			- Added the functions:
				- Set-Window
				- Get-ApplicationRegistration
				- New-ApplicationRegistration
				- Update-ApplicationRegistrationRequiredResourceAccess
				- Remove-ApplicationRegistration
				- New-ApplicationRegistrationClientSecret
				- Remove-ApplicationRegistrationClientSecret
				- Get-ServicePrincipal
				- New-ServicePrincipal
				- Remove-ServicePrincipal
			- The new application registration is created and configured with "App Instance Property Lock" enabled by default
			- The existing application registration is offered to configure with "App Instance Property Lock" enabled
			- Changed variable "$aadtenantFQDN" to "$tenantFQDN"
			- Changed variable "$aadtenantID" to "$tenantID"
			- Changed all references of "AAD" to "Entra ID" or "EID"
			- Renamed other variables to better match their exact purpose
			- Renamed the script from "Create-Update-Delete-AAD-PK-Vulnerability-Scanning-App.ps1" to "Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1"
	
		v0.7, 2023-07-29, Jorge de Almeida Pinto [MVP-EMS]:
			- Remove the "-ForceRefresh" parameter from the CMDlet "Connect-MgGraph" as it was not available anymore in newer Microsoft.Graph PoSH modules
			- Updated the way to connect to Azure AD
				- If the parameter 'updateAPIPerms' is used, the Connect-AzAccount is used first through username/password and if applicable MFA, then an access token is retrieved for MSGRAPH to use with Connect-MgGraph
				- If the parameter 'updateAPIPerms' is NOT used, the Connect-MgGraph is used through username/password and if applicable MFA
			- Changed order of importing the PowerShell module for Az.Accounts and Microsoft.Graph. If the Azure Accounts PowerShell Module is imported AFTER importing the Microsoft Graph PowerShell Module, the following
			   error occurs when executing Connect-AzAccount:
			   Method not found: 'System.Threading.Tasks.Task`1<Azure.Identity.AuthenticationRecord> Azure.Identity.InteractiveBrowserCredential.AuthenticateAsync(Azure.Core.TokenRequestContext, System.Threading.CancellationToken)'.
			- Some minor updates in the code when checking for null/empty values

		v0.6, 2023-06-27, Jorge de Almeida Pinto [MVP-EMS]:
			- Added the MSFT Graph roles "Device.Read.All" to the list of MSFT Graph required roles

		v0.5, 2023-06-06, Jorge de Almeida Pinto [MVP-EMS]:
			- When running just the script without any parameter, it will display where information can be retrieved to use the script
			- Small textual updates
			- Moved to start using the Microsoft Graph PowerShell modules as Azure AD And Azure AD Preview PowerShell modules are planned for deprecation
				- https://learn.microsoft.com/en-us/powershell/microsoftgraph/migration-steps?
				- https://learn.microsoft.com/en-us/powershell/microsoftgraph/azuread-msoline-cmdlet-map
			- Now also displays the command line that was used when executing the script
			- Added the parameter to list all existing client secrets

		v0.4, 2022-11-21, Jorge de Almeida Pinto [MVP-EMS]:
			- Added the MSFT Graph roles "AuditLog.Read.All" to the list of MSFT Graph required roles

		v0.3, 2022-10-20, Jorge de Almeida Pinto [MVP-EMS]:
			- Fixed the name of the variable, after community feedback (Submitted by 'aps-support', THANK YOU!)
			- Changed the structure of the script for easier maintenance and to match other scripts
			- Moved the definition of MSFT Graph required roles into its own section for easier maintenance and better visibility
			- Added the MSFT Graph roles "RoleManagement.Read.All" and "UserAuthenticationMethod.Read.All" to the list of MSFT Graph required roles
			- Updated the logic, added try/catch, to give a nicer error when the initial authentication fails with either Connect-AzureAD or Connect-AzAccount

		v0.2, 2022-07-01, Jorge de Almeida Pinto [MVP-EMS]:
			- Added a default timer of 1 hour for the secret
			- Added the ability to provide a custom lifetime in days
			- Added a parameter to delete all the secrets present
			- Some code improvements

		v0.1, 2022-06-24, Jorge de Almeida Pinto [MVP-EMS]:
			- Initial version of the script
#>

<#
.SYNOPSIS
	This PoSH Script Creates The Application Registration In Entra ID For PK To Be Able To Scan For Vulnerabilities In Entra ID

.DESCRIPTION
    This PoSH script provides the following functions:
	- Create and update the Application Registration in Entra ID for PK To Be Able To Scan For Vulnerabilities In Entra ID
	- Delete the Application Registration in Entra ID
	- Assign the following MSFT Graph Application Permissions and consent those, when either creating or updating the app
		- AdministrativeUnit.Read.All
		- Application.Read.All
		- AuditLog.Read.All
		- Device.Read.All
		- Directory.Read.All
		- GroupMember.Read.All
		- IdentityRiskyUser.Read.All
		- Organization.Read.All
		- Policy.Read.All
		- PrivilegedAccess.Read.AzureAD
		- PrivilegedEligibilitySchedule.Read.AzureADGroup
		- Reports.Read.All
		- RoleEligibilitySchedule.Read.Directory
		- RoleManagement.Read.All
		- RoleManagement.Read.Directory
		- User.Read.All
		- UserAuthenticationMethod.Read.All
	- Create an client secret that by default is valid for an hour, when either creating or updating the app. If needed it is possible to provide a customer lifetime in days for the client secret. This is not recommended as it may be a security issue
	- Deleting all client secrets from the Application Registration in Entra ID
	- Display the tenant ID, the application ID, the assigned and consented permissions, and the client secret to be used in the Purple Knight executable

.PARAMETER tenantFQDN
	With This Parameter, You Can Specify The Tenant FQDN To Target The Entra ID Tenant To create The Application Registration In

.PARAMETER appRegDisplayName
	With This Parameter, You Can Specify The Name For The Application Registration
	
.PARAMETER customLifetimeSecretInDays
	With This Parameter, You Can Specify The Custom Lifetime Of The Client Secret In Days

.PARAMETER createOrUpdateApp
	With This Parameter, You Can Specify To Either Create A New Application Registration Or Update An Existing Application Registration
	
.PARAMETER deleteApp
	With This Parameter, You Can Specify To Delete An Existing Application Registration
	
.PARAMETER updateAPIPerms
	With This Parameter, You Can Specify To Update The API Permissions When Either Creating A New Application Registration Or Updating An Existing Application Registration

.PARAMETER createClientSecret
	With This Parameter, You Can Specify To Create A New Client Client Secret When Either Creating A New Application Registration Or Updating An Existing Application Registration

.PARAMETER deleteAllClientSecrets
	With This Parameter, You Can Specify To Delete All Existing Client Secrets Whether Those Are Expired Or Not (Only When App Already Exists!)

.PARAMETER listAllClientSecrets
	With This Parameter, You Can Specify To List All Existing Client Secrets (Only When App Already Exists!)

.EXAMPLE
	Create A Purple Knight Vulnerability Scanning App In Entra ID OR Update The Purple Knight Vulnerability Scanning App In Entra ID With Updated API Permissions And A New Client Secret (Existing Client Secrets WILL NOT Be Deleted!)

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -createOrUpdateApp -updateAPIPerms -createClientSecret

.EXAMPLE
	Update An Existing Purple Knight Vulnerability Scanning App In Entra ID With Updated API Permissions

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -createOrUpdateApp -updateAPIPerms

.EXAMPLE
	Update An Existing Purple Knight Vulnerability Scanning App In Entra ID With A New Client Secret (Existing Client Secrets WILL NOT Be Deleted!)

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -createOrUpdateApp -createClientSecret

.EXAMPLE
	List All Existing Client Secrets On The Existing Purple Knight Vulnerability Scanning App In Entra ID

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -listAllClientSecrets

.EXAMPLE
	Delete All Existing Client Secrets On The Existing Purple Knight Vulnerability Scanning App In Entra ID

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -createOrUpdateApp -deleteAllClientSecrets

.EXAMPLE
	Delete An Existing Purple Knight Vulnerability Scanning App In Entra ID

	.\Create-Update-Delete-EID-PK-Vulnerability-Scanning-App.ps1 -tenantFQDN XXX.ONMICROSOFT.COM -appRegDisplayName "Semperis Purple Knight Vulnerability Scanning App" -deleteApp

.NOTES
	- Requires PSMSALNet Module (https://github.com/SCOMnewbie/PSMSALNet) to authenticate against Entra ID for all action performed by the script
	- To create, configure AND consent application permissions for the Microsoft Graph, at least membership of the "Global Administrator" built-in role is required
	- To create and configure (without assigning and consenting application permissions for the Microsoft Graph), at least membership of the "Application Administrator" or "Cloud Application Administrator" built-in role is required
	- To create a new client secret, at least application ownership is required of the existing application
#>

###
# Functions Used In Script
###
# FUNCTION: Set Window Position And Size.
# Source: https://github.com/proxb/PowerShell_Scripts/blob/master/Set-Window.ps1
Function Set-Window {
    <#
        .SYNOPSIS
            Sets the window size (height,width) and coordinates (x,y) of a process window.

        .DESCRIPTION
            Sets the window size (height,width) and coordinates (x,y) of a process window.

        .PARAMETER ProcessName
            Name of the process to determine the window characteristics

        .PARAMETER X
            Set the position of the window in pixels from the top.

        .PARAMETER Y
            Set the position of the window in pixels from the left.

        .PARAMETER Width
            Set the width of the window.

        .PARAMETER Height
            Set the height of the window.

        .PARAMETER Passthru
            Display the output object of the window.

        .NOTES
            Name: Set-Window
            Author: Boe Prox
            Version History
                1.0//Boe Prox - 11/24/2015
                    - Initial build

        .OUTPUT
            System.Automation.WindowInfo

        .EXAMPLE
            Get-Process powershell | Set-Window -X 2040 -Y 142 -Passthru

            ProcessName Size     TopLeft  BottomRight
            ----------- ----     -------  -----------
            powershell  1262,642 2040,142 3302,784   

            Description
            -----------
            Set the coordinates on the window for the process PowerShell.exe
        
    #>
    [OutputType('System.Automation.WindowInfo')]
    [cmdletbinding()]
    Param (
        [parameter(ValueFromPipelineByPropertyName=$True)]
        $ProcessName,
        [int]$X,
        [int]$Y,
        [int]$Width,
        [int]$Height,
        [switch]$Passthru
    )
    Begin {
        Try{
            [void][Window]
        } Catch {
        Add-Type @"
              using System;
              using System.Runtime.InteropServices;
              public class Window {
                [DllImport("user32.dll")]
                [return: MarshalAs(UnmanagedType.Bool)]
                public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

                [DllImport("User32.dll")]
                public extern static bool MoveWindow(IntPtr handle, int x, int y, int width, int height, bool redraw);
              }
              public struct RECT
              {
                public int Left;        // x position of upper-left corner
                public int Top;         // y position of upper-left corner
                public int Right;       // x position of lower-right corner
                public int Bottom;      // y position of lower-right corner
              }
"@
        }
    }
    Process {
        $Rectangle = New-Object RECT
        $Handle = (Get-Process -Name $ProcessName).MainWindowHandle
        $Return = [Window]::GetWindowRect($Handle,[ref]$Rectangle)
        If (-NOT $PSBoundParameters.ContainsKey('Width')) {            
            $Width = $Rectangle.Right - $Rectangle.Left            
        }
        If (-NOT $PSBoundParameters.ContainsKey('Height')) {
            $Height = $Rectangle.Bottom - $Rectangle.Top
        }
        If ($Return) {
            $Return = [Window]::MoveWindow($Handle, $x, $y, $Width, $Height,$True)
        }
        If ($PSBoundParameters.ContainsKey('Passthru')) {
            $Rectangle = New-Object RECT
            $Return = [Window]::GetWindowRect($Handle,[ref]$Rectangle)
            If ($Return) {
                $Height = $Rectangle.Bottom - $Rectangle.Top
                $Width = $Rectangle.Right - $Rectangle.Left
                $Size = New-Object System.Management.Automation.Host.Size -ArgumentList $Width, $Height
                $TopLeft = New-Object System.Management.Automation.Host.Coordinates -ArgumentList $Rectangle.Left, $Rectangle.Top
                $BottomRight = New-Object System.Management.Automation.Host.Coordinates -ArgumentList $Rectangle.Right, $Rectangle.Bottom
                If ($Rectangle.Top -lt 0 -AND $Rectangle.LEft -lt 0) {
                    Write-Warning "Window is minimized! Coordinates will not be accurate."
                }
                $Object = [pscustomobject]@{
                    ProcessName = $ProcessName
                    Size = $Size
                    TopLeft = $TopLeft
                    BottomRight = $BottomRight
                }
                $Object.PSTypeNames.insert(0,'System.Automation.WindowInfo')
                $Object            
            }
        }
    }
}

# FUNCTION: Get The OpenID Configuration For The Specified Entra ID Tenant FQDN.
Function Get-OpenIDConfiguration {
	<#
		.SYNOPSIS
			Get The OpenID Configuration For The Specified Entra ID Tenant FQDN.

		.DESCRIPTION
			Get The OpenID Configuration For The Specified Entra ID Tenant FQDN.

		.PARAMETER tenantFQDN
			The FQDN Of The Entra ID Tenant Being Targeted.
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE, ValueFromPipeline = $TRUE, ValueFromPipelineByPropertyName = $TRUE, HelpMessage = 'Please Specify The Entra ID Tenant FQDN')]
		[ValidateNotNullOrEmpty()]
		[String]$tenantFQDN
	)

	Begin {
		# Specify The Tenant Specific Discovery Endpoint URL
		$oidcConfigDiscoveryURL = "https://login.microsoftonline.com/$tenantFQDN/v2.0/.well-known/openid-configuration"
	}

	Process {
		$oidcTenantConfig = Invoke-RestMethod -Uri $oidcConfigDiscoveryURL

		Return $oidcTenantConfig
	}
}

# FUNCTION: Get The Entra ID Tenant ID From The OIDC Configuration.
Function Get-TenantID {
	<#
		.SYNOPSIS
			Get The Entra ID Tenant ID From The OIDC Configuration.

		.DESCRIPTION
			Get The Entra ID Tenant ID From The OIDC Configuration.

		.PARAMETER oidcTenantConfig
			The OIDC Configuration Of The Entra ID Tenant Being Targeted.
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[System.Management.Automation.PSObject]$oidcTenantConfig
	)

	Begin {
		$tenantID = $null
	}

	Process {
		$tenantID = $oidcTenantConfig.authorization_endpoint.Split("/")[3]

		Return $tenantID
	}
}

# FUNCTION: Get The Application Registration With A Specific Application ID Or Specific Display Name
Function Get-ApplicationRegistration {
	<#
		.SYNOPSIS
			Get The Application Registration With A Specific Application ID Or Specific Display Name

		.DESCRIPTION
			Get The Application Registration With A Specific Application ID Or Specific Display Name

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER appRegDisplayName
			The Application Display Name Assigned And Configured On The Application Registration To Process
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$appRegDisplayName
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($appRegDisplayName)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-appRegDisplayName' And Specify The Application Registration Display Name" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications?`$filter=appId+eq+'$applicationId'" -Method GET -Headers $requestHeader -ErrorAction Stop
				If ([string]::IsNullOrEmpty($($response.value | Out-String))) {
					Write-Verbose "Unable To Find The Application Registration With App Id '$applicationId' Because It Does Not Exist"
				} Else {
					Write-Verbose "Found The Application Registration '$($response.value.displayName)' With Object Id '$($response.value.id)' And App Id '$($response.value.appId)'"
				}
			}
			If (-not [string]::IsNullOrEmpty($appRegDisplayName)) {
				$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications?`$filter=displayName+eq+'$appRegDisplayName'" -Method GET -Headers $requestHeader -ErrorAction Stop
				If ([string]::IsNullOrEmpty($($response.value | Out-String))) {
					Write-Verbose "Unable To Find The Application Registration With Display Name '$appRegDisplayName' Because It Does Not Exist In This Tenant"
				} Else {
					Write-Verbose "Found The Application Registration '$($response.value.displayName)' With Object Id '$($response.value.id)' And App Id '$($response.value.appId)'"
				}
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
			}

			Throw $errorMessage
		}

		Return $response.value
	}
}

# FUNCTION: Create The Application Registration With Specific Details
Function New-ApplicationRegistration {
	<#
		.SYNOPSIS
			Create The Application Registration With Specific Details

		.DESCRIPTION
			Create The Application Registration With Specific Details

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER appRegDisplayName
			The Application Registration Display Name
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$appRegDisplayName
	)

	Begin {
		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @{
			displayName                       = $appRegDisplayName
			description                       = "Application For Semperis Purple Knight To Support Scanning Of Defined Entra ID Components"
			signInAudience                    = "AzureADMyOrg"
			servicePrincipalLockConfiguration = @{"isEnabled" = $true; "allProperties" = $true} # App Instance Property Lock
			web                               = @{"redirectUris" = @("http://localhost")}
		}
		Write-Verbose "Request Body.............................: $($requestBody | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
			Write-Verbose "Created The Application Registration '$($response.displayName)' Object Id '$($response.id)' And With App Id '$($response.appId)'"
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Update The Required Resource Access Of An Existing Application Registration With A Specific Application Registration Object Id Or A Specific Application Id.
Function Update-ApplicationRegistrationRequiredResourceAccess {
	<#
		.SYNOPSIS
			Update The Required Resource Access Of An Existing Application Registration With A Specific Application Registration Object Id Or A Specific Application Id.

		.DESCRIPTION
			Update The Required Resource Access Of An Existing Application Registration With A Specific Application Registration Object Id Or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER applicationRegistrationObjectId
			The Object Id Of The Application Registration To Process

		.PARAMETER requiredResourceAccess
			The Required Resource Access, Consisting Of A Collection Of "Resource ID And A Collection Of Either Roles Or Scopes", To Configure On The Application Registration
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationRegistrationObjectId,
		
		[Parameter(Mandatory = $TRUE)]
		[PSCustomObject[]]$requiredResourceAccess
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-applicationRegistrationObjectId' And Specify The Application Registration Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @(
			[PSCustomObject]@{
				requiredResourceAccess = $requiredResourceAccess
			}
		)
		Write-Verbose "Request Body.............................: $($requestBody | ConvertTo-Json -Depth 99)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications(appId='{$applicationId}')" -Method PATCH -Headers $requestHeader -Body $($requestBody | ConvertTo-Json -Depth 99) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Updated The Required Resource Access For Application Registration With Application Id '$applicationId'"
			}
			If (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications/$applicationRegistrationObjectId" -Method PATCH -Headers $requestHeader -Body $($requestBody | ConvertTo-Json -Depth 99) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Updated The Required Resource Access For Application Registration With Object Id '$applicationRegistrationObjectId'"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(400) Bad Request*") {
					Write-Verbose "Error: (400) Bad Request - The Required Resource Access Collection Has Not Been Defined Correctly"
				}
				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Update The App Instance Property Lock Configuration Of An Existing Application Registration With A Specific Object Id Or A Specific Application Id.
Function Update-ApplicationRegistrationAppInstPropLockConfig {
	<#
		.SYNOPSIS
			Update The App Instance Property Lock Configuration Of An Existing Application Registration With A Specific Object Id Or A Specific Application Id.

		.DESCRIPTION
			Update The App Instance Property Lock Configuration Of An Existing Application Registration With A Specific Object Id Or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER applicationRegistrationObjectId
			The Object Id Of The Application Registration To Process
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationRegistrationObjectId
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-applicationRegistrationObjectId' And Specify The Application Registration Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @{
			servicePrincipalLockConfiguration = @{"isEnabled" = $true; "allProperties" = $true} # App Instance Property Lock
		}
		Write-Verbose "Request Body.............................: $($requestBody | ConvertTo-Json -Depth 99)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications(appId='{$applicationId}')" -Method PATCH -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Updated The Required Resource Access For Application Registration With Application Id '$applicationId'"
			}
			If (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications/$applicationRegistrationObjectId" -Method PATCH -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Updated The Required Resource Access For Application Registration With Object Id '$applicationRegistrationObjectId'"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Remove An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.
Function Remove-ApplicationRegistration {
	<#
		.SYNOPSIS
			Remove An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.DESCRIPTION
			Remove An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER applicationRegistrationObjectId
			The Object Id Of The Application Registration To Process
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationRegistrationObjectId
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-applicationRegistrationObjectId' And Specify The Application Registration Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications(appId='{$applicationId}')" -Method DELETE -Headers $requestHeader -ErrorAction Stop
				Write-Verbose "Deleted Application Registration With Application Id '$applicationId'"
			}
			If (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications/$applicationRegistrationObjectId" -Method DELETE -Headers $requestHeader -ErrorAction Stop
				Write-Verbose "Deleted Application Registration With Object Id '$applicationRegistrationObjectId'"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Add A New Client Secret To An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.
Function New-ApplicationRegistrationClientSecret {
	<#
		.SYNOPSIS
			Add A New Client Secret To An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.DESCRIPTION
			Add A New Client Secret To An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER applicationRegistrationObjectId
			The Object Id Of The Application Registration To Process

		.PARAMETER customLifetimeSecretInDays
			The Custom Lifetime In Days For The New Secret To Be Added To The Existing Application Registration. When Nothing Is Specified The Default Will Be 1 Hour.
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationRegistrationObjectId,
		
		[Parameter(Mandatory = $FALSE)]
		[string]$customLifetimeSecretInDays
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-applicationRegistrationObjectId' And Specify The Application Registration Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}
		
		$internetIP = (Invoke-WebRequest -uri "http://ifconfig.me/ip").Content
		$geoLocationInfo = Invoke-RestMethod -Method Get -Uri "http://ip-api.com/json/$internetIP"
		$geoLocationTimeZone = [System.TimeZoneInfo]::FindSystemTimeZoneById($($geoLocationInfo.timezone))
		$geoLocationDateTime = [System.TimeZoneInfo]::ConvertTimeFromUtc((Get-Date).ToUniversalTime(), $geoLocationTimeZone)
		$defaultInHours = 1
		$startDate = $geoLocationDateTime											# Start Date/Time Is Generated Based On The Internet Connected GeoLocation, And Not The Start/Time Of The Local Computer!
		If ([string]::IsNullOrEmpty($customLifetimeSecretInDays)) {
			$endDate = $startDate.AddHours($defaultInHours)
		} Else {
			$endDate = $startDate.AddDays($customLifetimeSecretInDays)
		}

		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @{
			passwordCredential = @{
				customKeyIdentifier = $null;
				displayName         = "Purple Knight Client Secret (Generated $(Get-Date $startDate -Format 'yyyy-MM-dd HH:mm:ss'))";
				startDateTime       = $(Get-Date $startDate -Format "yyyy-MM-ddTHH:mm:ss.0Z")
				endDateTime         = $(Get-Date $endDate -Format "yyyy-MM-ddTHH:mm:ss.0Z")
			}
		}
		Write-Verbose "Request Body.............................: $($requestBody | ConvertTo-Json)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications(appId='{$applicationId}')/addPassword" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Added A New Client Secret To The Application Registration With Application Id '$applicationId' With A Lifetime Of $(If ([string]::IsNullOrEmpty($customLifetimeSecretInDays)) {"$defaultInHours Hour(s)"} Else {"$customLifetimeSecretInDays Day(s)"})"
			}
			If (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications/$applicationRegistrationObjectId/addPassword" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Added A New Client Secret To The Application Registration With Object Id '$applicationRegistrationObjectId' With A Lifetime Of $(If ([string]::IsNullOrEmpty($customLifetimeSecretInDays)) {"$defaultInHours Hour(s)"} Else {"$customLifetimeSecretInDays Day(s)"})"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Remove An Existing Client Secret From An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.
Function Remove-ApplicationRegistrationClientSecret {
	<#
		.SYNOPSIS
			Remove An Existing Client Secret From An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.DESCRIPTION
			Remove An Existing Client Secret From An Existing Application Registration With A Specific Application Registration Object Id or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Application Registration To Process

		.PARAMETER applicationRegistrationObjectId
			The Object Id Of The Application Registration To Process

		.PARAMETER keyIdentifier
			The Key Identifier (Guid) Of The Password Credential (Client Secret) On An Existing Application Registration
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationRegistrationObjectId,
		
		[Parameter(Mandatory = $TRUE)]
		[string]$keyIdentifier
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-applicationRegistrationObjectId' And Specify The Application Registration Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @{
			keyId = $keyIdentifier
		}
		Write-Verbose "Request Body.............................: $($requestBody | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications(appId='{$applicationId}')/removePassword" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Removed An Existing Client Secret With Key Id '$keyIdentifier' From The Application Registration With Application Id '$applicationId'"
			}
			If (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/applications/$applicationRegistrationObjectId/removePassword" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
				Write-Verbose "Removed An Existing Client Secret With Key Id '$keyIdentifier' From The Application Registration With Object Id '$applicationRegistrationObjectId'"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(400) Bad Request*") {
					Write-Verbose "Error: (400) Bad Request - The Client Secret With Key Id '$keyIdentifier' Does Not Exist On The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"})"
				}
				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Application Registration With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($applicationRegistrationObjectId)) {"Object Id '$applicationRegistrationObjectId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Get The Service Principal With A Specific Application ID Or Specific Service Principal Display Name
Function Get-ServicePrincipal {
	<#
		.SYNOPSIS
			Get The Service Principal With A Specific Application ID Or Specific Service Principal Display Name

		.DESCRIPTION
			Get The Service Principal With A Specific Application ID Or Specific Service Principal Display Name

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Service Principal To Process

		.PARAMETER svcPrincDisplayName
			The Application Display Name Assigned And Configured On The Service Principal To Process
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$svcPrincDisplayName
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($svcPrincDisplayName)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-svcPrincDisplayName' And Specify The Service Principal Display Name" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/servicePrincipals?`$filter=appId+eq+'$applicationId'" -Method GET -Headers $requestHeader -ErrorAction Stop
				If ([string]::IsNullOrEmpty($($response.value | Out-String))) {
					Write-Verbose "Unable To Find The Service Principal With App Id '$applicationId' Because It Does Not Exist In This Tenant"
				} Else {
					Write-Verbose "Found The Service Principal '$($response.value.displayName)' With Object Id '$($response.value.id)' And App Id '$($response.value.appId)'"
				}
			}
			If (-not [string]::IsNullOrEmpty($svcPrincDisplayName)) {
				$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/servicePrincipals?`$filter=displayName+eq+'$svcPrincDisplayName'" -Method GET -Headers $requestHeader -ErrorAction Stop
				If ([string]::IsNullOrEmpty($($response.value | Out-String))) {
					Write-Verbose "Unable To Find The Service Principal With Display Name '$svcPrincDisplayName' Because It Does Not Exist In This Tenant"
				} Else {
					Write-Verbose "Found The Service Principal '$($response.value.displayName)' With Object Id '$($response.value.id)' And App Id '$($response.value.appId)'"
				}
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
			}

			Throw $errorMessage
		}

		Return $response.value
	}
}

# FUNCTION: Create The Service Principal With A Specific Application ID
Function New-ServicePrincipal {
	<#
		.SYNOPSIS
			Create The Service Principal With A Specific Application ID

		.DESCRIPTION
			Create The Service Principal With A Specific Application ID

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Service Principal
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$applicationId
	)

	Begin {
		$requestHeader = $null
		$requestBody = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Define The Request Body To Execute The Required Action
		$requestBody = @{
			appId = $applicationId
		}
		Write-Verbose "Request Body.............................: $($requestBody | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			$response = Invoke-RestMethod -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/servicePrincipals" -Method POST -Headers $requestHeader -Body $($requestBody | ConvertTo-Json) -ContentType "application/json; charset=UTF-8" -ErrorAction Stop
			Write-Verbose "Created The Service Principal '$($response.displayName)' With App Id '$($response.appId)' And Object Id '$($response.id)'"
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(400) Bad Request*") {
					Write-Verbose "Error: (400) Bad Request - The Application Registration With Application Id '$applicationId' Does Not Exist In This Tenant"
				}
				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(409) Conflict*") {
					Write-Verbose "Error: (409) Conflict - The Service Principal With Application Id '$applicationId' Already Exists In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

# FUNCTION: Remove An Existing Service Principal With A Specific Service Principal Object Id or A Specific Application Id.
Function Remove-ServicePrincipal {
	<#
		.SYNOPSIS
			Remove An Existing Service Principal With A Specific Service Principal Object Id or A Specific Application Id.

		.DESCRIPTION
			Remove An Existing Service Principal With A Specific Service Principal Object Id or A Specific Application Id.

		.PARAMETER accessToken
			The Access Token To Be Used To Execute The Operation

		.PARAMETER applicationId
			The Application ID Assigned And Configured On The Service Principal To Process

		.PARAMETER servicePrincipalId
			The Object Id Of The Service Principal To Process
	#>

	[cmdletbinding()]
	Param(
		[Parameter(Mandatory = $TRUE)]
		[ValidateNotNullOrEmpty()]
		[string]$accessToken,

		[Parameter(Mandatory = $FALSE)]
		[string]$applicationId,

		[Parameter(Mandatory = $FALSE)]
		[string]$servicePrincipalId
	)

	Begin {
		# Making Sure The Correct Combination Of Parameters Are Used
		If ([string]::IsNullOrEmpty($applicationId) -And [string]::IsNullOrEmpty($servicePrincipalId)) {
			Write-Error "The Correct Combination Of Parameters Is Not Being Used"
			Write-Host " * You Need To Either Specify '-applicationId' And Specify An Application Id Or '-servicePrincipalId' And Specify The Service Principal Object Id" -ForegroundColor red
			Write-Host ""

			BREAK
		}

		$requestHeader = $null
		$response = $null
	}

	Process {
		# Define The Request Header To Execute The Required Action
		$requestHeader = @{
			Authorization = "Bearer $accessToken"
		}
		Write-Verbose "Request Header...........................: $($requestHeader | Out-String)"

		# Get The Response From The Microsoft Graph
		Try {
			If (-not [string]::IsNullOrEmpty($applicationId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/servicePrincipals(appId='{$applicationId}')" -Method DELETE -Headers $requestHeader -ErrorAction Stop
				Write-Verbose "Deleted Service Principal With Application Id '$applicationId'"
			}
			If (-not [string]::IsNullOrEmpty($servicePrincipalId)) {
				$response = Invoke-WebRequest -UseBasicParsing -Uri "https://graph.microsoft.com/v1.0/servicePrincipals/$servicePrincipalId" -Method DELETE -Headers $requestHeader -ErrorAction Stop
				Write-Verbose "Deleted Service Principal With Object Id '$servicePrincipalId'"
			}
		} Catch {
			If ($_.ErrorDetails.Message) {
				$errorMessage = $_.ErrorDetails.Message
			} Else {
				$errorMessage = $_

				If ($_ -like "*(401) Unauthorized*") {
					Write-Verbose "Error: (401) Unauthorized - Not Authenticated, Or Access Token Has Expired"
				}
				If ($_ -like "*(404) Not Found*") {
					Write-Verbose "Error: (404) Not Found - The Service Principal With $(If (-not [string]::IsNullOrEmpty($applicationId)) {"Application Id '$applicationId'"} ElseIf (-not [string]::IsNullOrEmpty($servicePrincipalId)) {"Object Id '$servicePrincipalId'"}) Does Not Exist In This Tenant"
				}
			}

			Throw $errorMessage
		}

		# Return
		Return $response
	}
}

###
# Clear The Screen
###
Clear-Host

###
# Configure The Appropriate Screen And Buffer Size To Make Sure Everything Fits Nicely
###
$randomNr = Get-Random -Minimum 1000 -Maximum 9999
$windowTitle = "+++ CREATE/UPDATE/DELETE PURPLE KNIGHT VULNERABILITY SCANNING APP IN ENTRA ID +++ ($randomNr)"
$uiConfig = (Get-Host).UI.RawUI
$uiConfig.WindowTitle = $windowTitle
$poshProcess = Get-Process | Where-Object {$_.MainWindowTitle -eq $windowTitle}
$poshProcessName = $poshProcess.ProcessName
$poshProcessId = $poshProcess.Id
If ($poshProcessName -like "*WindowsTerminal*") {
	Get-Process -Id $poshProcessId | Set-Window -X 100 -Y 100 -Width 1800 -Height 800 # -Passthru
} Else {
	$uiConfig.ForegroundColor = "Yellow"
	$uiConfigBufferSize = $uiConfig.BufferSize
	$uiConfigBufferSize.Width = 200
	$uiConfigBufferSize.Height = 9999
	$uiConfigScreenSizeMax = $uiConfig.MaxPhysicalWindowSize
	$uiConfigScreenSizeMaxWidth = $uiConfigScreenSizeMax.Width
	$uiConfigScreenSizeMaxHeight = $uiConfigScreenSizeMax.Height
	$uiConfigScreenSize = $uiConfig.WindowSize
	If ($uiConfigScreenSizeMaxWidth -lt 200) {
		$uiConfigScreenSize.Width = $uiConfigScreenSizeMaxWidth
	} Else {
		$uiConfigScreenSize.Width = 200
	}
	If ($uiConfigScreenSizeMaxHeight -lt 50) {
		$uiConfigScreenSize.Height = $uiConfigScreenSizeMaxHeight - 5
	} Else {
		$uiConfigScreenSize.Height = 50
	}
	$uiConfig.BufferSize = $uiConfigBufferSize
	$uiConfig.WindowSize = $uiConfigScreenSize
}

###
# Definition Of Some Constants
###
$execDateTime = Get-Date
$startDateTime = $execDateTime.ToString("yyyy-MM-dd HH:mm:ss")
$scriptFullPath = $MyInvocation.MyCommand.Definition
$scriptCmdLineUsed = $MyInvocation.Line
$scriptFolderPath = Split-Path $scriptFullPath
$currentScriptName = Split-Path $scriptFullPath -Leaf
$scriptParameterListUsed = $PSBoundParameters
$argsCount = $PSBoundParameters.Count
$userAccount = [Security.Principal.WindowsIdentity]::GetCurrent()
$localComputerName = $(Get-CimInstance -Class Win32_ComputerSystem).Name
$fqdnADDomainOfComputer = $(Get-CimInstance -Class Win32_ComputerSystem).Domain
$fqdnOfComputer = $localComputerName + "." + $fqdnADDomainOfComputer
$clientIdAndNameMappings = @{}
$clientIdAndNameMappings["14d82eec-204b-4c2f-b7e8-296a70dab67e"] = "Microsoft Graph Command Line Tools"
$clientIdAndNameMappings["1950a258-227b-4e31-a9cf-717495945fc2"] = "Microsoft Azure PowerShell"
$msftGraphListOfRequiredPermissions = @()
$msftGraphListOfRequiredPermissions += "AdministrativeUnit.Read.All"
$msftGraphListOfRequiredPermissions += "Application.Read.All"
$msftGraphListOfRequiredPermissions += "AuditLog.Read.All"
$msftGraphListOfRequiredPermissions += "Device.Read.All"
$msftGraphListOfRequiredPermissions += "Directory.Read.All"
$msftGraphListOfRequiredPermissions += "GroupMember.Read.All"
$msftGraphListOfRequiredPermissions += "IdentityRiskyUser.Read.All"
$msftGraphListOfRequiredPermissions += "Organization.Read.All"
$msftGraphListOfRequiredPermissions += "Policy.Read.All"
$msftGraphListOfRequiredPermissions += "PrivilegedAccess.Read.AzureAD"
$msftGraphListOfRequiredPermissions += "PrivilegedEligibilitySchedule.Read.AzureADGroup"
$msftGraphListOfRequiredPermissions += "Reports.Read.All"
$msftGraphListOfRequiredPermissions += "RoleEligibilitySchedule.Read.Directory"
$msftGraphListOfRequiredPermissions += "RoleManagement.Read.All"
$msftGraphListOfRequiredPermissions += "RoleManagement.Read.Directory"
$msftGraphListOfRequiredPermissions += "User.Read.All"
$msftGraphListOfRequiredPermissions += "UserAuthenticationMethod.Read.All"

###
# Loading Any Applicable Libraries
###
# N.A.

###
# Execute Any Additional Actions Required For The Script To Run Successfully
###
# N.A.

###
# Start Of Script
###
# Presentation Of Script Header
Write-Host ""
Write-Host "                                                           ********************************************************************************" -ForeGroundColor Magenta
Write-Host "                                                           *                                                                              *" -ForeGroundColor Magenta
Write-Host "                                                           * --> Create/Update/Delete Purple Knight Vulnerability Scanning App In EID <-- *" -ForeGroundColor Magenta
Write-Host "                                                           *                                                                              *" -ForeGroundColor Magenta
Write-Host "                                                           *                       Written By: Jorge de Almeida Pinto                     *" -ForeGroundColor Magenta
Write-Host "                                                           *                                    SEMPERIS                                  *" -ForeGroundColor Magenta
Write-Host "                                                           *                                                                              *" -ForeGroundColor Magenta
Write-Host "                                                           *                               $version                               *" -ForeGroundColor Magenta
Write-Host "                                                           *                                                                              *" -ForeGroundColor Magenta
Write-Host "                                                           ********************************************************************************" -ForeGroundColor Magenta
Write-Host ""
Write-Host "                                                           __________                    .__            ____  __.      .__       .__     __" -ForeGroundColor Magenta
Write-Host "                                                           \______   \__ _______________ |  |   ____   |    |/ _| ____ |__| ____ |  |___/  |" -ForeGroundColor Magenta
Write-Host "                                                            |     ___/  |  \_  __ \____ \|  | _/ __ \  |      <  /    \|  |/ ___\|  |  \   __\" -ForeGroundColor Magenta
Write-Host "                                                            |    |   |  |  /|  | \/  |_> >  |_\  ___/  |    |  \|   |  \  / /_/  >   Y  \  |" -ForeGroundColor Magenta
Write-Host "                                                            |____|   |____/ |__|  |   __/|____/\___  > |____|__ \___|  /__\___  /|___|  /__|" -ForeGroundColor Magenta
Write-Host "                                                                                  |__|             \/          \/    \/  /_____/      \/" -ForeGroundColor Magenta
Write-Host "                    ____   ____    .__                            ___.   .__.__  .__  __             _________                           .__                    _____" -ForeGroundColor Magenta
Write-Host "                    \   \ /   /_ __|  |   ____   ________________ \_ |__ |__|  | |__|/  |_ ___.__.  /   _____/ ____ _____    ____   ____ |__| ____    ____     /  _  \ ______ ______" -ForeGroundColor Magenta
Write-Host "                     \   Y   /  |  \  |  /    \_/ __ \_  __ \__  \ | __ \|  |  | |  \   __<   |  |  \_____  \_/ ___\\__  \  /    \ /    \|  |/    \  / ___\   /  /_\  \\____ \\____ \" -ForeGroundColor Magenta
Write-Host "                      \     /|  |  /  |_|   |  \  ___/|  | \// __ \| \_\ \  |  |_|  ||  |  \___  |  /        \  \___ / __ \|   |  \   |  \  |   |  \/ /_/  > /    |    \  |_> >  |_> >" -ForeGroundColor Magenta
Write-Host "                       \___/ |____/|____/___|  /\___  >__|  (____  /___  /__|____/__||__|  / ____| /_______  /\___  >____  /___|  /___|  /__|___|  /\___  /  \____|__  /   __/|   __/" -ForeGroundColor Magenta
Write-Host "                                             \/     \/           \/    \/                  \/              \/     \/     \/     \/     \/        \//_____/           \/|__|   |__|" -ForeGroundColor Magenta

###
# SECTION: SCRIPT DETAILS
###
Write-Host ""
Write-Host "Current Date & Time.................: $startDateTime"
Write-Host "Run By..............................: $($userAccount.Name)"
Write-Host "Run On Machine......................: $fqdnOfComputer"
If ($psVersionTable.PSVersion -lt [version]"7.4") {
	Write-Host "PowerShell Version..................: $($psVersionTable.PSVersion.ToString())" -ForegroundColor Red
} Else {
	Write-Host "PowerShell Version..................: $($psVersionTable.PSVersion.ToString())" -ForegroundColor Green
}
Write-Host ""
Write-Host "Script Full Path....................: $scriptFullPath"
Write-Host "Script Folder Path..................: $scriptFolderPath"
Write-Host "Script Command Line Used............: $scriptCmdLineUsed"
Write-Host ""

###
# Checking PowerShell Version
###
If ($psVersionTable.PSVersion -lt [version]"7.4") {
	Write-Host ""
	Write-Host "This Script Depends On The PowerShell Module 'PSMSALNet' Which Has A minum Requirement Of PowerShell Version 7.4." -Foregroundcolor Red
	Write-Host ""
	Write-Host "Please Visit 'https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.4'..." -Foregroundcolor Red
	Write-Host ""

	Write-Host ""
	Write-Host " => Aborting Script..." -ForegroundColor Red
	Write-Host ""

	BREAK
}

###
# Checking If Required Parameters Have Been Specified
###
If ($scriptParameterListUsed.Keys -notcontains "createOrUpdateApp" -And $scriptParameterListUsed.Keys -notcontains "deleteApp" -And $scriptParameterListUsed.Keys -notcontains "updateAPIPerms" -And $scriptParameterListUsed.Keys -notcontains "createClientSecret" -And $scriptParameterListUsed.Keys -notcontains "deleteAllClientSecrets" -And $scriptParameterListUsed.Keys -notcontains "listAllClientSecrets") {
	Write-Host ""
	Write-Host "No Parameters Were Used To Actually Tell The Script WHAT To Do." -Foregroundcolor Red
	Write-Host ""
	Write-Host "Available Parameters..." -Foregroundcolor Red
	Get-Help .\$currentScriptName -Full
	Write-Host ""
	Write-Host "Please Visit 'https://github.com/Semperis/PK-AADAppReg/' To Learn More About Using The Script." -Foregroundcolor Red
	Write-Host ""

	Write-Host ""
	Write-Host " => Aborting Script..." -ForegroundColor Red
	Write-Host ""

	BREAK
}

###
# Loading PSMSALNet PowerShell Module
###
$moduleName = "PSMSALNet"
$psMSALNetModule = Get-Module -Name $moduleName -ListAvailable
If ([String]::IsNullOrEmpty($psMSALNetModule)) {
	Write-Host ""
	Write-Host "The $moduleName PowerShell Module IS NOT Installed" -ForegroundColor Red
	Write-Host ""
	Write-Host " => The $moduleName PowerShell Module Can Be Installed From An Elevated PowerShell Command Prompt By Running:" -ForegroundColor Red
	Write-Host "    - 'Install-Module $moduleName'" -ForegroundColor Red
	Write-Host ""
	Write-Host " => Aborting Script..." -ForegroundColor Red
	Write-Host ""

	BREAK
} Else {
	$psMSALNetModuleVersionInstalled = $psMSALNetModule.Version
	$psMSALNetModuleVersionAvailable = (Find-Module -Name $moduleName).Version
	If ([version]$psMSALNetModuleVersionAvailable -gt $psMSALNetModuleVersionInstalled) {
		Write-Host ""
		Write-Host "A Newer Version Of The '$moduleName' PowerShell Module Is Available For Download/Install..." -ForegroundColor Red
		Write-Host ""
	}
}

If ($psMSALNetModule.count -gt 1) {
	$latestVersionPSMSALNetModule = ($psMSALNetModule | Select-Object version | Sort-Object)[-1]
	$psMSALNetModule  = $psMSALNetModule | Where-Object {$_.version -eq $latestVersionMSFTGraphModule.version}
}
Import-Module $psMSALNetModule

###
# Getting Entra ID Tenant Details
###
$oidcConfig = Get-OpenIDConfiguration -tenantFQDN $tenantFQDN
$tenantID = Get-TenantID -oidcTenantConfig $oidcConfig
If (!$([guid]::TryParse($tenantID, $([ref][guid]::Empty)))) {
	Write-Host ""
	Write-Host "Specified Tenant '$tenantFQDN' DOES NOT Exist..." -ForegroundColor Red
	Write-Host ""
	Write-Host " => Aborting Script..." -ForegroundColor Red
	Write-Host ""

	BREAK
}

Write-Host ""
Write-Host "Tenant FQDN.........................: $tenantFQDN"
Write-Host "Tenant ID...........................: $tenantID"
Write-Host ""

###
# Authenticating Against Entra ID Tenant
###
$clientId1 = "14d82eec-204b-4c2f-b7e8-296a70dab67e" # "Microsoft Graph Command Line Tools"
Write-Host ""
Write-Host "### Getting Access Token For Client App '$($clientIdAndNameMappings[$clientId1])' And The MSFT Graph API Resource In Entra ID Tenant '$tenantFQDN'..." -ForegroundColor Cyan
Write-Host ""
Try {
	$entraTokenParametersHT1 = @{
	  ClientId    = $clientId1
	  TenantId    = $tenantID
	  RedirectUri = 'http://localhost'
	  Resource    = 'GraphAPI'
	  Permissions = @('Directory.AccessAsUser.All')
	  verbose     = $false
	  ErrorAction = "Stop"
	}
	$entraTokenMSGraphAPI = Get-EntraToken -PublicAuthorizationCodeFlow @entraTokenParametersHT1
} Catch {
	Write-Host ""
	Write-Host " => Getting Access Token For Client App '$($clientIdAndNameMappings[$clientId1])' And The MSFT Graph API Resource In Entra ID Tenant '$tenantFQDN' Failed..." -ForegroundColor Red
	Write-Host ""
	Write-Host "    - Exception Type......: $($_.Exception.GetType().FullName)" -ForegroundColor Red
	Write-Host "    - Exception Message...: $($_.Exception.Message)" -ForegroundColor Red
	Write-Host "    - Error On Script Line: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
	Write-Host ""
	Write-Host " => Aborting Script..." -ForegroundColor Red
	Write-Host ""
	Write-Host ""

	Try {
		Remove-Module $psMSALNetModule -ErrorAction SilentlyContinue
	} Catch {
	}

	BREAK
}
$accessTokenMSGraphAPI = $entraTokenMSGraphAPI.AccessToken

If ($updateAPIPerms) {
	$clientId2 = "1950a258-227b-4e31-a9cf-717495945fc2" # "Microsoft Azure PowerShell"
	Write-Host ""
	Write-Host "### Getting Access Token For Client App '$($clientIdAndNameMappings[$clientId2])' And The AD Ibiza UX Resource In Entra ID Tenant '$tenantFQDN'..." -ForegroundColor Cyan
	Write-Host ""
	Try {
		$entraTokenParametersHT2 = @{
			ClientId       = $clientId2
			TenantId       = $tenantID
			RedirectUri    = 'http://localhost'
			Resource       = 'Custom'
			CustomResource = '74658136-14ec-4630-ad9b-26e160ff0fc6' # Resource ID For Azure AD Portal Management UI (A.k.a. ADIbizaUX => https://main.iam.ad.ext.azure.com)
			Permissions    = @('user_impersonation')
			verbose        = $false
			ErrorAction    = "Stop"
		}
		$entraTokenAADPortalMgmtUI = Get-EntraToken -PublicAuthorizationCodeFlow @entraTokenParametersHT2
	} Catch {
		Write-Host ""
		Write-Host " => Getting Access Token For Client App '$($clientIdAndNameMappings[$clientId2])' And The AD Ibiza UX Resource In Entra ID Tenant '$tenantFQDN' Failed..." -ForegroundColor Red
		Write-Host ""
		Write-Host "    - Exception Type......: $($_.Exception.GetType().FullName)" -ForegroundColor Red
		Write-Host "    - Exception Message...: $($_.Exception.Message)" -ForegroundColor Red
		Write-Host "    - Error On Script Line: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
		Write-Host ""
		Write-Host " => Aborting Script..." -ForegroundColor Red
		Write-Host ""
		Write-Host ""

		Try {
			Remove-Module $psMSALNetModule -ErrorAction SilentlyContinue
		} Catch {
		}

		BREAK
	}
	$accessTokenAADPortalMgmtUI = $entraTokenAADPortalMgmtUI.AccessToken
}

###
# Creating/Updating The Purple Knight Vulnerability Scanning App In Entra ID
###
If ($createOrUpdateApp) {
	Write-Host ""
	Write-Host "### Creating/Updating The Purple Knight Vulnerability Scanning App In Entra ID..." -ForegroundColor Cyan
	Write-Host ""
	$eidPKVulnerabilityScanAppReg = Get-ApplicationRegistration -accessToken $accessTokenMSGraphAPI -appRegDisplayName $appRegDisplayName
	If (-not [String]::IsNullOrEmpty($eidPKVulnerabilityScanAppReg)) {
		$eidPKVulnerabilityScanAppRegObjectID = $eidPKVulnerabilityScanAppReg.Id
		$eidPKVulnerabilityScanAppRegApplicationID = $eidPKVulnerabilityScanAppReg.AppId
		Write-Host " => Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Already Exists..." -ForegroundColor Yellow
		Write-Host ""

		If (-not ($eidPKVulnerabilityScanAppReg.servicePrincipalLockConfiguration.isEnabled -eq $true -And $eidPKVulnerabilityScanAppReg.servicePrincipalLockConfiguration.allProperties -eq $true)) {
			Write-Host "    # The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID IS NOT Properly Configured For 'App Instance Property Lock'..." -ForegroundColor Yellow
			Write-Host "      More Info: https://learn.microsoft.com/en-us/entra/identity-platform/howto-configure-app-instance-property-locks" -ForegroundColor Yellow
			Write-Host ""
			$configConfirmation = Read-Host "    # Would You Like To Properly Configure 'App Instance Property Lock'? [YES | NO]"
			Write-Host ""

			If ($configConfirmation.ToUpper() -eq "YES" -Or $configConfirmation.ToUpper() -eq "Y") {
				$responseUpdAppRegAppInstPropLockConfig = Update-ApplicationRegistrationAppInstPropLockConfig -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID
				If ($responseUpdAppRegAppInstPropLockConfig.StatusCode -eq 204) {
					Write-Host "    # The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID HAS Been Reconfigured For 'App Instance Property Lock'..." -ForegroundColor Green
					Write-Host ""
				} Else {
					Write-Host "    # The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Failed To Be Reconfigured For 'App Instance Property Lock'..." -ForegroundColor Red
					Write-Host ""
				}
			} Else {
				Write-Host "    # The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID HAS NOT Been Reconfigured For 'App Instance Property Lock'..." -ForegroundColor Yellow
				Write-Host ""
				Write-Host ""
			}
		}
	} Else {
		# Creating The Purple Knight Vulnerability Scanning Application Registration In Entra ID
		$eidPKVulnerabilityScanAppReg = New-ApplicationRegistration -accessToken $accessTokenMSGraphAPI -appRegDisplayName $appRegDisplayName
		If (-not [String]::IsNullOrEmpty($eidPKVulnerabilityScanAppReg)) {
			$eidPKVulnerabilityScanAppRegObjectID = $eidPKVulnerabilityScanAppReg.Id
			$eidPKVulnerabilityScanAppRegApplicationID = $eidPKVulnerabilityScanAppReg.AppId
			Write-Host " => Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Has Been Created Successfully..." -ForegroundColor Green
			Write-Host ""
		} Else {
			Write-Host " => Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Failed To Be Created..." -ForegroundColor Red
			Write-Host ""
			Write-Host ""

			Try {
				Remove-Module $psMSALNetModule -ErrorAction SilentlyContinue
			} Catch {
			}

			BREAK
		}

		# Creating The Purple Knight Vulnerability Scanning Svc Principal In Entra ID
		Write-Host " => Waiting A Few Seconds Before Continuing..." -ForegroundColor Yellow
		Write-Host ""
		Start-Sleep -s 10
		
		$eidPKVulnerabilityScanSvcPrinc = New-ServicePrincipal -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID
		If (-not [String]::IsNullOrEmpty($eidPKVulnerabilityScanSvcPrinc)) {
			$eidPKVulnerabilityScanSvcPrincObjectID = $eidPKVulnerabilityScanSvcPrinc.Id
			$eidPKVulnerabilityScanSvcPrincApplicationID = $eidPKVulnerabilityScanSvcPrinc.AppId
			Write-Host " => Purple Knight Vulnerability Scanning Service Principal '$appRegDisplayName' In Entra ID Has Been Created Successfully..." -ForegroundColor Green
			Write-Host ""
		} Else {
			Write-Host " => Purple Knight Vulnerability Scanning Service Principal '$appRegDisplayName' In Entra ID Failed To Be Created..." -ForegroundColor Red
			Write-Host ""
			Write-Host ""

			Try {
				Remove-Module $psMSALNetModule -ErrorAction SilentlyContinue
			} Catch {
			}

			BREAK
		}
	}

	# Configuring API Permissions And Granting Admin Consent For The Purple Knight Vulnerability Scanning Application Registration In Entra ID
	If ($updateAPIPerms) {
		$msftGraphSvcPrincipal = Get-ServicePrincipal -accessToken $accessTokenMSGraphAPI -svcPrincDisplayName "Microsoft Graph" # MSFT Graph
		$resourceAppId = $msftGraphSvcPrincipal.AppId
		$resourceAccess = @()
		$msftGraphListOfRequiredPermissions | ForEach-Object{
			$appRoleName = $_
			$appRoleID = ($msftGraphSvcPrincipal.AppRoles | Where-Object {$_.Value -eq $appRoleName}).Id
			$resourceAccessEntry = [PSCustomObject]@{
				id = $appRoleID
				type = "Role"
			}
			$resourceAccess += $resourceAccessEntry
		}
		$requiredResourceAccess = @(
			[PSCustomObject]@{
				resourceAppId = $resourceAppID
				resourceAccess = $resourceAccess
			}
		)
		$responseUpdAppRegReqResAccess = Update-ApplicationRegistrationRequiredResourceAccess -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID -requiredResourceAccess $requiredResourceAccess
		If ($responseUpdAppRegReqResAccess.StatusCode -eq 204) {
			Write-Host " => API Permissions For Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Have Been (Re-)Configured Successfully..." -ForegroundColor Green
			Write-Host ""
		} Else {
			Write-Host " => API Permissions For Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Failed To Be (Re-)Configured..." -ForegroundColor Red
			Write-Host ""
		}

		# Inspired By: https://stackoverflow.com/questions/63529599/how-to-grant-admin-consent-to-an-azure-aad-app-in-powershell
		$permissionsScopes = @()
		$requiredResourceAccess | ForEach-Object {
			$resourceAppID = $null
			$resourceAppID = $_.resourceAppId
			$resourceAccess = $null
			$resourceAccess = $_.resourceAccess
			$resource = $null
			$resource = $(Get-ServicePrincipal -accessToken $accessTokenMSGraphAPI -applicationId $resourceAppID)
			$resourceName = $null
			$resourceName = $resource.DisplayName
			$resourceAccessValues = @()
			$resourceAccess | ForEach-Object{
				$resourceAccessType = $null
				$resourceAccessType = $_.type
				$resourceAccessID = $null
				$resourceAccessID = $_.id
				$resourceAccessValue = $null
				If ($resourceAccessType -eq "Role") {
					$resourceAccessValue = "AppRole: " + ($resource.AppRoles | Where-Object{$_.id -eq $resourceAccessID}).Value
				}
				If ($resourceAccessType -eq "scope") {
					$resourceAccessValue = "Scope: " + ($resource.Oauth2Permissions | Where-Object{$_.id -eq $resourceAccessID}).Value
				}
				$resourceAccessValues += $resourceAccessValue
			}
			$permissionsScopes += $($resourceName + "|" + $($resourceAccessValues -join ","))
		}
		$requestHeaders = @{
			'Authorization' = 'Bearer ' + $accessTokenAADPortalMgmtUI
			'X-Requested-With'= 'XMLHttpRequest'
			'x-ms-client-request-id'= [guid]::NewGuid()
			'x-ms-correlation-id' = [guid]::NewGuid()
		}
		$azureMgmtAdminConsentEIDPKVulnerabilityScanAppEndpointURL = "https://main.iam.ad.ext.azure.com/api/RegisteredApplications/$eidPKVulnerabilityScanAppRegApplicationID/Consent?onBehalfOfAll=true"
		Write-Host " => Waiting A Few Seconds Before Continuing To Make Sure The Application Registration, The Service Principal And Permissions Are In Place..." -ForegroundColor Yellow
		Write-Host ""
		Start-Sleep -s 30
		Try {
			[void]$(Invoke-RestMethod -Uri $azureMgmtAdminConsentEIDPKVulnerabilityScanAppEndpointURL -Headers $requestHeaders -Method POST -ErrorAction Stop)
			Write-Host " => Admin Consent Successfully Granted For The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID..." -ForegroundColor Green
			Write-Host "    WARNING: Although Possible, This IS NOT Officially Supported!..." -ForegroundColor Green
			Write-Host ""
		} Catch {
			Write-Host " => Failed To Grant Admin Consent For The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID..." -ForegroundColor Red
			Write-Host ""
			Write-Host "    - Exception Type......: $($_.Exception.GetType().FullName)" -ForegroundColor Red
			Write-Host "    - Exception Message...: $($_.Exception.Message)" -ForegroundColor Red
			Write-Host "    - Error On Script Line: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
			Write-Host ""
			Write-Host ""
		}
	}

	# Deleting All Existing Client Secrets For The Configured Permissions For The Purple Knight Vulnerability Scanning App In Entra ID
	If ($deleteAllClientSecrets) {
		Write-Host " => Checking If Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Has Client Secrets..." -ForegroundColor Yellow
		Write-Host ""
		$eidPKVulnerabilityScanClientSecrets = $eidPKVulnerabilityScanAppReg.PasswordCredentials
		If (($eidPKVulnerabilityScanClientSecrets | Measure-Object).Count -gt 0) {
			$eidPKVulnerabilityScanClientSecrets | ForEach-Object {
				$responseRemAppRegClntScrt = Remove-ApplicationRegistrationClientSecret -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID -keyIdentifier $_.keyId
				If ($responseRemAppRegClntScrt.StatusCode -eq 204) {
					Write-Host "    # Client Secret '$($_.displayName)' (KeyID: $($_.keyId)) Has Been Deleted Successfully..." -ForegroundColor Green
					Write-Host ""
				} Else {
					Write-Host "    # Client Secret '$($_.displayName)' (KeyID: $($_.keyId)) Failed To Be Deleted..." -ForegroundColor Red
					Write-Host ""
				}
			}
		} Else {
			Write-Host "    # Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID DOES NOT have Any Client Secrets Configured..." -ForegroundColor Yellow
			Write-Host ""
		}
	}

	# Creating A Client Secret For The Configured Permissions For The Purple Knight Vulnerability Scanning App In Entra ID
	If ($createClientSecret) {
		If ([string]::IsNullOrEmpty($customLifetimeSecretInDays)) {
			$responseNewAppRegClntScrt = New-ApplicationRegistrationClientSecret -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID
		} Else {
			$responseNewAppRegClntScrt = New-ApplicationRegistrationClientSecret -accessToken $accessTokenMSGraphAPI -applicationId $eidPKVulnerabilityScanAppRegApplicationID -customLifetimeSecretInDays $customLifetimeSecretInDays
		}
		If ($responseNewAppRegClntScrt.StatusCode -eq 200) {
			$eidPKVulnerabilityScanClientSecret = $responseNewAppRegClntScrt.Content | ConvertFrom-Json
			Write-Host " => Client Secret For Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Has Been Created..." -ForegroundColor Green
			Write-Host ""
		} Else {
			Write-Host " => Client Secret For Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Failed To Be Created..." -ForegroundColor Red
			Write-Host ""
		}
	}

	# Displaying The Required Data For The Purple Knight Vulnerability Scanning App In Entra ID
	Write-Host "### Displaying The Required Data For The Purple Knight Vulnerability Scanning App In Entra ID..." -ForegroundColor Cyan
	Write-Host ""
	Write-Host " => Tenant ID......................: '$tenantID' <------------------------- Needed For Purple Knight Application" -ForegroundColor Yellow
	Write-Host " => Application Name...............: '$appRegDisplayName'" -ForegroundColor Yellow
	Write-Host " => App Registration Object ID.....: '$eidPKVulnerabilityScanAppRegObjectID'" -ForegroundColor Yellow
	Write-Host " => App Registration App ID........: '$eidPKVulnerabilityScanAppRegApplicationID' <------------------------- Needed For Purple Knight Application" -ForegroundColor Yellow
	If ($updateAPIPerms) {
		Write-Host " => API Permissions................:" -ForegroundColor Yellow
		$permissionsScopes | ForEach-Object{
			$resourceApp = $null
			$resourceApp = $_.Split("|")[0]
			Write-Host "    - Resource.....................: $resourceApp..." -ForegroundColor Yellow
			$_.Split("|")[1].Split(",") | ForEach-Object{
				Write-Host "      * Permissions................: $($_)..." -ForegroundColor Yellow
			}
		}
	}
	If ($createClientSecret) {
		Write-Host " => Client Secret..................: '$($eidPKVulnerabilityScanClientSecret.SecretText)' <--------------------- Needed For Purple Knight Application" -ForegroundColor Yellow
		If ($customLifetimeSecretInDays) {
			Write-Host " => Custom Lifetime Client Secret..: '$customLifetimeSecretInDays Days'" -ForegroundColor Yellow
		} Else {
			Write-Host " => Default Lifetime Client Secret.: '1 Hour'" -ForegroundColor Yellow
		}
		Write-Host " => Start Date.....................: '$($eidPKVulnerabilityScanClientSecret.StartDateTime)'" -ForegroundColor Yellow
		Write-Host " => End Date.......................: '$($eidPKVulnerabilityScanClientSecret.EndDateTime)'" -ForegroundColor Yellow
		Write-Host ""
		Write-Host "WARNING: Make Sure To Store The Client Secret Specified Above In A Secure Location Like E.g. A Password Vault And Restrict Access To That Credential!!!" -ForegroundColor Red
	}
	Write-Host ""
}

# Listing All Existing Client Secrets For The Purple Knight Vulnerability Scanning Application Registration In Entra ID
If ($listAllClientSecrets) {
	$eidPKVulnerabilityScanAppReg = Get-ApplicationRegistration -accessToken $accessTokenMSGraphAPI -appRegDisplayName $appRegDisplayName
	If (-not [String]::IsNullOrEmpty($eidPKVulnerabilityScanAppReg)) {
		$eidPKVulnerabilityScanAppRegObjectID = $eidPKVulnerabilityScanAppReg.Id
		$eidPKVulnerabilityScanAppRegApplicationID = $eidPKVulnerabilityScanAppReg.AppId
		Write-Host " => Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' Exists In Entra ID..." -ForegroundColor Yellow
		Write-Host ""

		# Displaying The Required Data For The Purple Knight Vulnerability Scanning Application Registration In Entra ID
		Write-Host "### Displaying The Required Data For The Purple Knight Vulnerability Scanning Application Registration In Entra ID..." -ForegroundColor Cyan
		Write-Host ""
		Write-Host " => Tenant FQDN....................: '$tenantFQDN'" -ForegroundColor Yellow
		Write-Host " => Tenant ID......................: '$tenantID'" -ForegroundColor Yellow
		Write-Host " => Application Name...............: '$appRegDisplayName'" -ForegroundColor Yellow
		Write-Host " => App Registration Object ID.....: '$eidPKVulnerabilityScanAppRegObjectID'" -ForegroundColor Yellow
		Write-Host " => App Registration App ID........: '$eidPKVulnerabilityScanAppRegApplicationID'" -ForegroundColor Yellow
		Write-Host ""
		$eidPKVulnerabilityScanClientSecrets = $eidPKVulnerabilityScanAppReg.PasswordCredentials
		If ($eidPKVulnerabilityScanClientSecrets) {
			Write-Host " => The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID Has The Following Client Secrets Configured..." -ForegroundColor Yellow
			$eidPKVulnerabilityScanClientSecrets | FT DisplayName,StartDateTime,EndDateTime,keyId
		} Else {
			Write-Host " => The Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' In Entra ID DOES NOT Have Any Client Secrets Configured..." -ForegroundColor Yellow
			Write-Host ""
		}
	} Else {
		Write-Host " => Purple Knight Vulnerability Scanning Application Registration '$appRegDisplayName' DOES NOT Exist In Entra ID..." -ForegroundColor Yellow
		Write-Host ""
	}
}

###
# Deleting The Purple Knight Vulnerability Scanning App In Entra ID
###
If ($deleteApp) {
	Write-Host ""
	Write-Host "### Deleting The Purple Knight Vulnerability Scanning App '$appRegDisplayName' In Entra ID..." -ForegroundColor Cyan
	Write-Host ""
	$eidPKVulnerabilityScanAppReg = Get-ApplicationRegistration -accessToken $accessTokenMSGraphAPI -appRegDisplayName $appRegDisplayName
	
	If (-not [String]::IsNullOrEmpty($eidPKVulnerabilityScanAppReg)) {
		$deleteConfirmation = Read-Host " => Do You Really Want To Continue And Delete The Specified Purple Knight Vulnerability Scanning App In Entra ID? [YES | NO]"
		Write-Host ""
		If ($deleteConfirmation.ToUpper() -eq "YES" -Or $deleteConfirmation.ToUpper() -eq "Y") {
			$responseRemAppReg = Remove-ApplicationRegistration -accessToken $accessTokenMSGraphAPI -applicationRegistrationObjectId $eidPKVulnerabilityScanAppReg.Id
			If ($responseRemAppReg.StatusCode -eq 204) {
				Write-Host " => Purple Knight Vulnerability Scanning App '$appRegDisplayName' In Entra ID Has Been Deleted Successfully..." -ForegroundColor Green
				Write-Host ""
			} Else {
				Write-Host " => Purple Knight Vulnerability Scanning App '$appRegDisplayName' In Entra ID Failed To Be Deleted..." -ForegroundColor Red
				Write-Host ""
			}
		} Else {
			Write-Host " => Purple Knight Vulnerability Scanning App '$appRegDisplayName' In Entra ID HAS NOT BEEN Deleted..." -ForegroundColor Yellow
			Write-Host ""
			Write-Host ""
		}
	} Else {
		Write-Host " => Purple Knight Vulnerability Scanning App '$appRegDisplayName' In Entra ID DOES NOT Exist..." -ForegroundColor Yellow
		Write-Host ""
		Write-Host ""
	}
}

###
# THE END OF THE SCRIPT
###
Try {
	Remove-Module $psMSALNetModule -ErrorAction SilentlyContinue
} Catch {
}
Write-Host ""
Write-Host " +++ DONE +++ " -ForegroundColor Cyan
Write-Host ""